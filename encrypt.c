#include "encrypt.h"

/*
================================================================================
encrypt

Acquires a crypt context, creates a hash using the password passed in, and 
encrypts the stringToEncrypt using the hash generated by the password. 
Returns a pointer to the encrypted bytes. 

dwSize is a pointer of the encryption size that's known once strToEncrypt
has been encrypted. 
================================================================================
*/
BYTE* encrypt(const char* strToEncrypt, const char* password, DWORD* dwSize) 
{
    HCRYPTPROV hProv;
    HCRYPTHASH hHash;
    HCRYPTKEY hKey;
    DWORD todwSize = (DWORD)strlen(strToEncrypt);
    BYTE* pBuffer;

    CryptAcquireContext(&hProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);

    CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash);
    CryptHashData(hHash, (BYTE*)password, strlen(password), 0);
    CryptDeriveKey(hProv, CALG_RC4, hHash, 0, &hKey);

    // Start Encryption
    CryptEncrypt(hKey, 0, 1, 0, NULL, &todwSize, todwSize);

    pBuffer = (BYTE*)malloc(todwSize);

    // todwSize is doubled here because the characters are wide
    strcpy_s((char*)pBuffer, todwSize * 2, strToEncrypt);

    CryptEncrypt(hKey, 0, 1, 0, pBuffer, &todwSize, todwSize);
    BYTE* pbReturn = pBuffer;

    // write the dwSize out param
    *dwSize = todwSize;

    // Clean up
    CryptDestroyKey(hKey);
    CryptDestroyHash(hHash);

    CryptReleaseContext(hProv, 0);

    if (GetLastError() != 0)
    {
        handleEncryptError("Error destroying crypt contexts");
    }

    return pbReturn;
}

/*
================================================================================
decrypt

Takes a pointer to the encrypted bytes, a password, and the encryption size.
Generates a hash using the password, and decrypts the encryptedBytes.
Returns a const string of the decrypted bytes.
================================================================================
*/
const char* decrypt(BYTE* encryptedBytes, const char* password, DWORD dwSize)
{
    HCRYPTPROV hProv;
    HCRYPTHASH hHash;
    HCRYPTKEY hKey;
    PBYTE pBuffer = _alloca(dwSize * 2);

    CryptAcquireContext(&hProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);

    CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash);
    CryptHashData(hHash, (BYTE*)password, strlen(password), 0);
    CryptDeriveKey(hProv, CALG_RC4, hHash, 0, &hKey);

    memcpy(pBuffer, encryptedBytes, dwSize * 2);

    CryptDecrypt(hKey, 0, 1, 0, pBuffer, &dwSize);

    char* msg = (char*)malloc(strlen((char*)pBuffer));
    strcpy_s(msg, dwSize * 2, (char*)pBuffer);

    // Clean up
    CryptDestroyKey(hKey);
    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    if (GetLastError() != 0)
    {
        handleEncryptError("Error destroying crypt contexts");
    }

    return msg;
}

/*
================================================================================
byteToString

Takes the number of bytes to be converted, a pointer to the bytes to be 
converted, and a pointer to a string where the bytes will be converted.
================================================================================
*/
void byteToString(DWORD cb, void* pv, LPSTR sz)
{
    // pv is array of BYTES to be converted
    // cb is number of BYTES in the array
    // sz is a pointer to the return string

    BYTE* pb = (BYTE*) pv; // Local pointer to BYTE in the BYTE array
    int b;

    for (int i = 0; i < cb; i++)
    { 
        // Get the first byte of the wide character, and convert to hex
        b = (*pb & 0xF0) >> 4;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A'; 

        // Get the second byte of the wide character, and convert to hex
        b = *pb & 0x0F;        
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';

        pb++; 
    }

    *sz++ = 0;
    *sz++ = '\0';
}

/*
================================================================================
handleEncryptError

Takes an error message and prints to the screen. Program will exit when called.
================================================================================
*/
void handleEncryptError(char* message) 
{
    printf("An error occurred during encryption/decryption.\n");
    printf("%s\n", message);
    printf("Error number: %lx\n", GetLastError());
    exit(1);
}
